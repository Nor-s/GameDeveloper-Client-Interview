# **전문가를 위한 C++(개정4판): 부록 A C++ 면접 예상 질문**

## **기본**

-   함수 사용법
-   헤더 파일 문법
-   네임스페이스의 기본 사용법
-   범위 기반 for문, 조건문, 조건 연산자, 변수 등 기본 문법

-   열거 타입
-   스택과 힙의 차이
-   동적 할당 배열
-   const
-   포인터와 레퍼런스의 개념과 차이점
-   auto 키워드

-   std::vector 와 같은 표준 라이브러리 컨테이너의 기본 사용법
-   구조적 바인딩 (C++17)
-   C++17 중첩 네임스페이스

### **질문 유형**

-   C++ 키워드의 정의
    -   답: 정의 + 사용 예 + 추가사항
        -   예: const의 용도는 레퍼런스 매개변수가 변경되지 않게 하기 위해서, 함수나 메서드에 객체를 전달할 때 복제방식보다는 const 레퍼런스로 전달하는 것이 더 좋음

## **스트링과 스트링 뷰, 현지화와 정규표현식**

-   std::string, std::string_view
-   std::string 클래스와 C 스타일 스트링의 차이점, C 스타일 스트링을 자제해야하는 이유
-   스트링을 정수와 부동소수점수를 비롯한 숫자 타입과 상호 변환방법
-   로 스트링 리터럴
-   현지화의 중요성
-   유니코드의 기본 개념
-   로케일과 패싯의 개념
-   정규표현식의 개념

### **질문 유형**

-   스트링 두 개를 서로 연결하는 방법

    -   C 스타일과 C++ 스타일 차이점 이야기?

-   현지화 : wchar_t 사용 => 프로젝트의 시작단계부터 현지화를 고려

-   로케일과 패싯에 대한 기본 개념

    -   텍스트와 숫자를 대상 국가나 언어에 맞게 표현해줌

-   유니코드

    -   기본 개념과 배경
    -   UTF-8, UTF-16

-   정규표현식의 기본 개념 + 스트링을 다룰 때 정규표현식으로 할 수 있는 일에 대해서 답변

## **코딩 스타일**

-   스타일은 굉장히 중요한 요소.
-   코드를 제대로 작성했다면 주석을 달 일이 많지 않음
-   주석은 메타 정보를 담는 용도
-   코드를 더 작은 단위로 쪼개는 분할 원칙
-   기존 코드를 깔끔하게 정리하기 위해 코드를 재구성하는 리팩토링 기법
-   명명규칙

### **질문 유형**

-   배경지식과는 관련없는 코드는 자제

    -   직군에 맞는 포트폴리오

-   예전에 작성한 코드를 그대로 제출하기보다는 새로 작성

    -   제출할만한 프로그램을 짧게나마 작성

-   문서작성 => 커뮤니케이션 능력

    -   CodeGuru, CodeProject 같은 사이트에 올린 글 활용
    -   다른 사람과 소통해서 코드를 효과적으로 활용할 수 있는 능력

-   깃허브 활용

## **C++ 활용 능력**

-   사용한 라이브러리에 대한 질문을 대비

-   디자인: 디자인을 사용한 이유를 잘 설득할 수 있도록 준비

-   예전에 자신이 디자인했던 기억을 구체적으로 떠올려 면접 과정에서 예제로 제시

-   추상화의 정의와 예에 대한 질문에 대비

-   디자인을 클래스 계층도와 같이 시각적으로 표현할 수 있도록 준비

-   코드 재사용의 장점을 설명

-   라이브러리 개념을 이해

-   처음부터 새로 만들 때와 기존 코드를 재사용할 때의 장단점 파악

-   빅오 표기법의 기초를 이해

-   표준라이브러리에서 제공하는 기능들 파악

-   디자인 패턴에 대한 개략적인 개념을 파악

### **질문 유형**

-   명확하지 않은 질문들
    -   프로그램을 제대로 디자인하기 위한 단계에 대해 설명하라
    -   추상화 원칙에 대해 설명하라
    -   예전에 수행한 프로젝트의 디자인에 대해 설명해 달라
-   디자인 관점에서 볼 때 표준 라이브러리의 장단점을 설명

    -   표준라이브러리에서 제공하는 기능의 방대함 + 표준화의 장점 + 사용하기 어렵다는 단점

-   ~라는 프로그램을 개발하는 과정 ?
    -   1. 요구사항 수집
    -   2. 초기 프로토타입을 구현하는 방법
    -   3. 라이브러리 언급 or 직접 구현하는 방법
        -   오픈소스 라이센스 언급 + codeguru, codeproject, boost, githb 등 언급

## **객체 지향 디자인**

-   절차형 패러다임과 객체지향 패러다임의 차이점
-   클래스와 객체의 차이점
-   컴포넌트, 속성, 동작 관점에서 클래스 표현
-   is-a 관계와 has-a 관계
-   다중 상속의 장단점

### **질문 유형**

-   객체지향 개념을 정의 or 계층도를 직접 그려봄

    -   간단한 예시 (카드게임 등 간단한 앱을 제시)

-   사고과정 => 자신있게 말함, 브레인스토밍, 면접관과 적극적 토론, 잘못답변해도 즉시 수정, 더 나은 방향 제시

-   클래스 다이어그램을 트리형태로 표현하는 것이 좋음 -> 각 클래스마다 메서드와 데이터 멤버를 개략적으로 표현

-   제시한 디자인이 좋다는 근거를 제시해 달라는 질문 + 어떠한 요구사항이 추가되면 어떻게 수정할 지?
    -   설득력이 중요

## **재사용을 고려한 디자인**

-   재사용을 고려한 디자인하는 방법을 질문
-   추상화 원칙
-   서브 시스템과 클래스 계층 생성 방법
-   인터페이스를 제대로 디자인하기 위한 일반적인 규칙
    -   구현에 대한 세부사항이 없이 public 메서드로만 구성된 인터페이스
-   템플릿과 상속이 필요한 경우

### **질문 유형**

-   지원자가 예전에 참여한 프로젝트에 대해 물어봄

    -   그 프로젝트의 모듈들을 다른 프로젝트에서도 활용한 적이 있는지도 언급

-   단순 코딩에 대한 질문
    -   항상 인터페이스에 대한 고려사항도 함께 언급

## **메모리 관리**

-   스마트 포인터의 개념과 메모리 관리에 대한 질문

    -   스마트 포인터보다 로우레벨의 메커니즘에대한 질문

-   스택과 힙을 그림으로 표현할 줄 알아야함

    -   내부 매커니즘을 이해하는 데 도움이됨

-   로우레벨 메모리 할당 및 해제 함수의 사용을 자제

    -   new, delete, new[], delete[], malloc() , free() 직접 호출 x

-   스마트 포인터 이해

    -   unique_ptr 을 기본으로 사용, 공유할 대상은 shared_ptr로 표현

-   unique_ptr은 make_unique로 생성
-   shared_ptr는 make_shared로 생성
-   auto_ptr은 절대 사용 금지
-   raw 레벨 메모리 할당 함수 사용 == malloc(), free() 보다는 new, delete, new[], delete[]를 사용
-   객체를 가리키는 포인터 배열을 사용할 대는 각 원소에 있는 포인터마다 메모리를 할당하고 해제해야함
    -   배열 할당 구문은 포인터까지 처리해주지 않음
-   메모리 할당 문제를 검새하주는 도구 (밸그라인드, Valgrind) => 메모리 문제를 쉽게 찾을 수 있음

### 질문 유형

-   코드를 던져주고 문제를 찾으라는 질문

    -   new, delete, new[], delete[] 대칭인지 확인

-   메모리 누수 등과 같은 메모리 관련 질문

-   포인터와 배열의 차이점

    -   7장의 포인터와 배열 내용

-   vector와 같은 표준 라이브러리 컨테이너를 사용하면 메모리를 알아서 관리 해주기 때문에 훨씬 좋다는 점 강조

## 클래스와 객체

-   클래스 정의에 대한 기본 문법
-   메서드와 데이터 멤버에 대한 접근 지정자
-   this 포인터 사용법
-   이름 결정 과정
-   스택과 힙의 관점에서 본 객체 생성과 소멸 과정
-   컴파일러가 생성자를 만들어주는 경우
-   생성자 이니셜라이저
-   복제 생성자와 대입연산자
-   생성자 위임
-   mutable 키워드
-   메서드 오버로딩과 기본 매개변수
-   const 멤버
-   friend 클래스와 메서드
-   객체에서 동적으로 할당된 메모리를 관리하는 방법
-   static 메서드와 데이터 멤버
-   인라인 메서드의 개념 + 컴파일러는 inline 키워드를 참조만 한다는 사실(무시가능)
-   인터페이스와 구현클래스를 분리하는 이유
    -   인터페이스는 public 메서드만 갖고 항상 일정한 형태로 유지, 구현이 변경되더라도 그대로 유지 가능
-   클래스 내부 멤버 이니셜라이저
-   명시적으로 디폴트로 지정하거나 삭제 하는 특수 멤버함수 (default, delete)
-   우측값과 좌측값 차이
-   우측값 레퍼런스
-   이동 생성자와 이동 대입연산자를 이용한 이동의미론
-   복제후 맞바꾸기 패턴의 개념과 용도
-   영의 규칙과 5의 규칙

### 질문 유형

-   mutable 키워드의 의미에 대해 설명해보세요 같은 C++ 용어 질문들

-   버그 찾기 유형

    -   문법 에러
    -   메모리 문제 (메모리 누수, 이중 삭제)
    -   바람직하지 않은 작성법 (c 스타일 string )
    -   스타일 에러 (변수 이름, 주석 빈약)

-   리턴 타입만 다르도록 메서드를 오버로딩할 수 없음

-   소유권을 표현할 때 일반 포인터를 절대로 사용하지 말고 스마트 포인터를 사용해야하는 이유 제시

-   이동 생성자, 이동 대입 연산자를 명시적으로 디폴트로 지정하는 이유 + 복제생성자와 복제 대입 연산자를 삭제하는 것이 좋은 이유

## 상속 활용

-   파생 클래스 문법
-   파생 클래스 관점에서 본 private, protected 의 차이점
-   메서드 오버라이딩과 virtual
-   오버로딩과 오버라이딩의 차이점
-   소멸자를 반드시 virtual로 지정해야 하는 이유
-   생성자 체인
-   업캐스팅과 다운캐스팅의 세부사항
-   다형성의 원칙
-   순수 virtual 메서드와 추상베이스 클래스
-   다중 상속
-   RTTI
-   상속한 생성자
-   클래스에 대한 final 키워드
-   override 와 final 키워드

### 질문 유형

-   private 와 protected 의 차이점
-   캐스팅 => 슬라이싱 현상

## 11장. C++의 까다롭고 유별난 부분

-   레퍼런스를 선언할 때 반드시 변수에 바인딩해야 하고, 한 번 바인딩되면 변경할 수 없다는 점
-   값 전달 방식 보다 레퍼런스 전달 방식이 나은 이유
-   const 의 다양한 사용 예
-   static 의 다양한 사용 예
-   C++의 다양한 타입 캐스팅 방법
-   타입 alias와 typedef 작동 방식
-   복잡한 문법을 사용하지 않고도 사용자 정의 리터럴을 간편하게 정의할 수 있다는 사실

### 질문 유형

-   const 와 static을 정의

    -   static 메서드와 static 데이터 멤버
    -   대표적인 예
    -   함수의 static 변수와 static 링크

-   레퍼런스 멤버변수
    -   생성자 이니셔라이저 사용
    -   레퍼런스에 바인딩할 변수를 생성자의 매개변수로 받도록 작성

## **12, 22장 템플릿으로 제네릭 코드 만들기, 고급 템플릿**

-   클래스 템플릿과 함수 템플릿 사용 방법
-   기본 클래스와 함수 템플릿 작성 방법
-   템플릿 인수 추론(생성자에 대한 템플릿 인수 추론 기능)
-   alias 템플릿의 개념 + typedef 보다 나은 이유
-   가변인수 템플릿
-   메타프로그래밍의 개념과 배경
-   타입 트레이트의 정의와 용도

### 질문 유형

-   배열과 같은 클래스 직접 구현 => 여러 타입을 받을 수 있는 템플릿

-   다른 문제를 해결하는 과정에서 살펴볼 때가 많음

-   메타프로그래밍을 이해
    -   팩토리얼을 컴파일 시간에 계산하는 간단한 예제 제시

## **13장 C++ I/O 완전 분석**

GUI 애플리케이션을 개발하는 업무에 지원한다면 I/O 스트림에 대해 질문하는 경우는 별로 없음

-   스트림의 정의
-   스트림을 이용한 기본적인 입출력방법
-   매니퓰레이터의 개념
-   스트림의 종류 (콘솔, 파일, 스트링 등)
-   에러 처리 기법

### 질문 유형

-   에러 처리부분을 빠뜨리지 않는 것이 중요

## **14. 에러 처리하기**

-   상용제품 수준의 코드 == 다양한 에러에 잘 대처하는 코드
-   익셉션을 const 레퍼런스로 잡기
-   기본적인 인셉션 타입 사용보다 익셉션 계층을 구성하는 것이 좋은 이유
-   익셉션이 발생했을 때 스택 풀기가 일어나는 과정
-   생성자와 소멸자에서 에러를 처리하는 방법
-   익셉션이 발생할 때 메모리 누수를 방지하도록 스마트 포인터를 사용하는 방법
-   C++에서 setjmp() 나 longjmp() 같은 C 함수를 절대로 사용 x

### 질문 유형

-   스택풀기 작동하는 과정
-   성능상의 이유로 익셉션 메커니즘을 전혀 사용하지 않는 경우

    -   nullptr나 에러코드 검사방식
    -   nothrow new

-   setjmp, longjmp == 스코프에 있는 소멸자를 건너뛰어버림

    -   C++에서는 사용할 수 없음

-   최신 컴파일러는 발생가능한 익셉션을 처리하는 코드에서 성능 오버헤드가 거의 없도록 컴파일함

## **15장 C++ 연산자 오버로딩**

-   레퍼런스를 보기 전에 한번 되짚어보기 좋은 주제

-   스트림 연산자 오버로딩, 연산자 오버로딩 중에서도 가장 흔히 볼 수 있으면서도 개념이 독특하기 때문

-   펑터의 개념과 생성 방법

-   메서드 연산자와 전역 함수의 장단점

-   어떤 연산자를 다른 연산자로 표현하는 방법
    -   `operator<=`를 `operator>`로 구현하는 방법

## **16, 17, 18, 21 장 표준 라이브러리**

-   표준라이브러리의 디자인에 대한 개념과 기본 사용법
-   다양한 종류의 컨테이너와 각각에 대한 반복자
-   표준 라이브러리 클래스 중에서도 가장 많이 사용되는 vector 사용법
-   map 과 같은 연관 컨테이너 사용법
-   연관 컨테이너와 비정렬 연관 컨테이너의 차이점
-   표준 라이브러리 알고리즘의 용도와 몇가지 기본제공 알고리즘

-   표준 라이브러리 알고리즘에서 람다 표현식을 사용하는 방법과 사례

-   remove-erase 패턴

-   C++17에서부터 추가된 표준 라이브러리 알고리즘의 병렬 지원 기능

-   표준 라이브러리 확장 방법

-   표준 라이브러리에 대한 의견

### 질문 유형

-   기본 개념을 정확히

-   연관 컨테이너와 비연관 컨테이너

-   반복자를 정의하는 방법

-   컨테이너에서 반복자를 사용하는 방법

-   remove-erase 패턴

-   표준 라이브러리에 대한 하이레벨 관점의 질문 중에서 표준 라이브러리 알고리즘을 사용해본 경험이나 표준 라이브러리를 확장해본 경험

-   람다 표현식

-   표준 라이브러리 알고리즘 적용 경험
